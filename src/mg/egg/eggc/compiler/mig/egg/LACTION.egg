------------------ ***** -----------------------------
-- Migration de la grammaire de LACTION-- vers la nouvelle syntaxe
------------------ ***** -----------------------------
--OPTIONS
option k =2;
option auto =true;
option version =6.0.0;
--ATTRIBUTS
inh table : TDS for
  LACTION , INSTS , INST , INST2 , AFF , ELSIF , CASE , CASES , VAR , EXPR , EXPRREL , REL , RELMEXPR , MEXPR , MEXPRTERME , TERME , TERMEFACTEUR , FACTEUR , APP , ARGS , ARGSX , EARGS;
inh reg : REGLE for
  LACTION;
inh avis : IVisiteurAction for
  LACTION , INSTS , INST , AFF , ELSIF , CASE , CASES , EXPR , EXPRREL , REL , RELMEXPR , MEXPR , MEXPRTERME , TERME , TERMEFACTEUR , FACTEUR , ARGS , ARGSX , EARGS , INST2 , APP;
inh act : LACT for
  LACTION , INSTS , INST , AFF , ELSIF , CASE , CASES , VAR , EXPR , EXPRREL , REL , RELMEXPR , MEXPR , MEXPRTERME , TERME , TERMEFACTEUR , FACTEUR , ARGS , ARGSX , EARGS , INST2 , APP;
inh tds_act : TDS_ACTION for
  INSTS , INST , AFF , ELSIF , CASE , CASES , VAR , EXPR , EXPRREL , REL , RELMEXPR , MEXPR , MEXPRTERME , TERME , TERMEFACTEUR , FACTEUR , ARGS , ARGSX , EARGS , INST2 , APP;
syn nom : STRING for
  CASE , OPBOOL , OPCOMP , OPADD , OPMUL;
syn entree : ENTREE for
  VAR;
inh hentree : ENTREE for
  INST2 , AFF , CASE , CASES;
syn code : STRING for
  LACTION , INSTS , INST , INST2 , AFF , ELSIF , CASE , CASES , EXPR , EXPRREL , REL , RELMEXPR , MEXPR , MEXPRTERME , TERME , TERMEFACTEUR , FACTEUR , APP;
inh hcode : STRING for
  EXPRREL , RELMEXPR , MEXPRTERME , TERMEFACTEUR , APP;
syn args : Vector for
  ARGS , EARGS , ARGSX;
inh hargs : Vector for
  ARGS , EARGS , ARGSX;
syn type : IType for
  TYPE , CASE , APP , EXPR , EXPRREL , REL , RELMEXPR , MEXPR , MEXPRTERME , TERME , TERMEFACTEUR , FACTEUR;
inh htype : IType for
  EXPRREL , RELMEXPR , MEXPRTERME , TERMEFACTEUR , APP;
syn types : Vector for
  ARGS , EARGS , ARGSX;
inh htypes : Vector for
  ARGS , EARGS , ARGSX;
inh res : Resolveur for
  TYPE , TGEN , XTYPE;
syn pars : Vector for
  TGEN , XTYPE;
syn offset : INTEGER for
  LACTION;
syn length : INTEGER for
  LACTION;

--TERMINAUX
space separateur is "[\r\n\t ]+";
comment commentaires is "\-\-[^\n]*\n";
comment big is "\-\*([^\*]|(\*+[^\*\-]))*\*+\-";
sugar t_point is "\."	aka	$.$;
sugar t_chapeau is "\^"	aka	$^$;
sugar t_virgule is "\,"	aka	$,$;
sugar t_pointvirgule is ";"	aka	$;$;
sugar t_deuxpoints is ":"	aka	$:$;
sugar t_affectation is "(=)"	aka	$=$;
sugar t_inf_egal is "\<="	aka	$<=$;
sugar t_inf is "\<"	aka	$<$;
sugar t_sup_egal is "\>="	aka	$>=$;
sugar t_sup is "\>"	aka	$>$;
sugar t_paro is "\("	aka	$($;
sugar t_parf is "\)"	aka	$)$;
sugar t_error is "error"	aka	$error$;
sugar t_attention is "warning"	aka	$warning$;
sugar t_write is "write"	aka	$write$;
sugar t_new is "new"	aka	$new$;
sugar t_instanceof is "instanceof"	aka	$instanceof$;
sugar t_plus is "\+"	aka	$+$;
sugar t_moins is "\-"	aka	$-$;
sugar t_mult is "\*"	aka	$*$;
sugar t_div is "\/"	aka	$/$;
sugar t_d_plus is "\+\."	aka	$+.$;
sugar t_d_moins is "\-\."	aka	$-.$;
sugar t_d_mult is "\*\."	aka	$*.$;
sugar t_d_div is "\/\."	aka	$/.$;
sugar t_et is "(\&|(\&\&))"	aka	$&$, $&&$;
sugar t_ou is "(\||(\|\|))"	aka	$|$, $||$;
sugar t_not is "(\~|\!)"	aka	$~$, $!$;
sugar t_append is "\@"	aka	$@$;
sugar t_aco is "\{"	aka	${$;
sugar t_acf is "\}"	aka	$}$;
sugar t_if is "if"	aka	$if$;
sugar t_elseif is "elseif"	aka	$elseif$;
sugar t_else is "else"	aka	$else$;
sugar t_match is "match"	aka	$match$;
sugar t_case is "case"	aka	$case$;
sugar t_default is "default"	aka	$default$;
sugar t_egal is "(==)"	aka	$==$;
sugar t_different is "((\/=)|(\!=))"	aka	$/=$, $!=$;
sugar t_nil is "((nil)|(null))"	aka	$nil$, $null$;
sugar t_true is "true"	aka	$true$;
sugar t_false is "false"	aka	$false$;
--sugar      t_chaine   is    "\""                  ;

sugar t_cro is "\["	aka	$[$;
sugar t_crf is "\]"	aka	$]$;
sugar t_string is "STRING"	aka	$STRING$;
sugar t_integer is "INTEGER"	aka	$INTEGER$;
sugar t_double is "DOUBLE"	aka	$DOUBLE$;
sugar t_char is "CHARACTER"	aka	$CHARACTER$;
term t_entier is "[0-9]+";
term t_flottant is "[0-9]*\.[0-9]+(e[\+\-]?[0-9]+)?";
-- chars

macro hex is "[0-9a-fA-F]";
macro uni is "\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]";
macro oct is "\\[0-3][0-7][0-7]";
-- le visiteur java les remplace par \n et \t

macro esc is "(\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]|\\[0-3][0-7][0-7]|\\[nrtfb]|\%[NT])";
macro scar is "[^\\\"]";
term t_chaine is "\"((\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]|\\[0-3][0-7][0-7]|\\[nrtfb]|\%[NT])|\\[\\\"]|[^\\\"])*\"";
macro ccar is "[^\\\']";
term t_car is "\'((\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]|\\[0-3][0-7][0-7]|\\[nrtfb]|\%[NT])|\\[\\\']|[^\\\'])\'";
term t_ident is "[a-zA-Z_][a-zA-Z_0-9]*";

--EXTERNES

--REGLES
LACTION-> #res t_aco INSTS t_acf #gen;
global
INTEGER offset;

INTEGER length;

#res{
  TDS_ACTION t;

  offset = LACTION^scanner.getOffset();
  LACTION^avis.resetIndent();
  LACTION^avis.incIndent();
  t = LACTION^act.getTds();
  INSTS^tds_act =  new TDS_ACTION(t);
}

#gen{
  STRING c;

  LACTION^code = LACTION^avis.insts()@INSTS^code;
  LACTION^avis.decIndent();
  length = LACTION^scanner.getOffset()+LACTION^scanner.getLength()-offset;
  LACTION^offset = offset;
  LACTION^length = length;
}

TYPE-> t_ident TGEN #gen;
#gen{

  TYPE^type = TYPE^res.getType(t_ident^txt, TGEN^pars);
}

TGEN-> #gen;
#gen{

  TGEN^pars = null;
}

TGEN-> t_inf TYPE XTYPE t_sup #gen;
#gen{

  XTYPE^pars.insertElementAt(TYPE^type, 0);
  TGEN^pars = XTYPE^pars;
}

XTYPE-> t_virgule TYPE XTYPE #add;
#add{

  XTYPE1^pars.insertElementAt(TYPE^type, 0);
  XTYPE^pars = XTYPE1^pars;
}

XTYPE-> #gen;
#gen{

  XTYPE^pars =  new Vector();
}

TYPE-> t_integer #gen;
#gen{

  TYPE^type = TYPE^res.getType("INTEGER");
}

TYPE-> t_double #gen;
#gen{

  TYPE^type = TYPE^res.getType("DOUBLE");
}

TYPE-> t_string #gen;
#gen{

  TYPE^type = TYPE^res.getType("STRING");
}

TYPE-> t_char #gen;
#gen{

  TYPE^type = TYPE^res.getType("CHARACTER");
}

INSTS-> #gen;
#gen{

  INSTS^code = "";
}

INSTS-> INST INSTS #gen;
#gen{

  INSTS^code = INSTS^avis.indent()@INST^code@"%N"@INSTS1^code;
}

INST-> #trans TYPE t_ident #hgen AFF t_pointvirgule #gen;
global
Resolveur r;

#trans{

  r = INST^act.getResolveur();
  TYPE^res = r;
}

#hgen{
  VAR v;
  TDS_ACTION t;
  ENTREE e;

  t = INST^tds_act;
  e = t.chercher(t_ident^txt);
  if (e!=null) {
    error(LACTION_local_yet_declared, t_ident^txt);
	}
  else {
    v =  new VAR(t_ident^txt, TYPE^type);
    AFF^hentree = v;
    t.ajouter_locale(v);
    r.contDecl(v);
	}
  
}

#gen{
  TDS_ACTION t;
  ENTREE e;

  t = INST^tds_act;
  e = t.chercher(t_ident^txt);
  INST^code = INST^avis.decl(e)@AFF^code;
}

AFF-> #gen;
#gen{

  AFF^code = "";
}

AFF-> t_affectation EXPR #gen;
#gen{
  Resolveur r;

  if (! AFF^hentree.affectable(AFF^act.getPos())) {
    error(LACTION_var_illegal_access, AFF^hentree.getNom());
	}
  else {
    AFF^hentree.setEtat(true);
    AFF^code = "%N"@AFF^avis.indent()@AFF^avis.aff(AFF^hentree, EXPR^code);
    r = AFF^act.getResolveur();
    r.contAff(AFF^hentree, EXPR^type);
	}
  
}

INST-> VAR #trans INST2 t_pointvirgule #gen;
#trans{

  INST2^hentree = VAR^entree;
}

#gen{

  INST^code = INST2^code;
}

INST2-> t_affectation EXPR #gen;
#gen{
  Resolveur r;

  if (! INST2^hentree.affectable(INST2^act.getPos())) {
    error(LACTION_var_illegal_access, INST2^hentree.getNom());
	}
  else {
    INST2^hentree.setEtat(true);
    INST2^code = INST2^avis.aff(INST2^hentree, EXPR^code);
    r = INST2^act.getResolveur();
    r.contAff(INST2^hentree, EXPR^type);
	}
  
}

INST2-> t_point t_ident #trans t_paro ARGS t_parf #hgen APP #gen;
#trans{
  Vector a;
  Vector ts;

  a =  new Vector();
  ARGS^hargs = a;
  ts =  new Vector();
  ARGS^htypes = ts;
}

#hgen{
  Resolveur r;
  STRING c;

  r = INST2^act.getResolveur();
  APP^htype = r.contFct(INST2^hentree.getType(), t_ident^txt, ARGS^types);
  c = INST2^avis.var(INST2^hentree);
  APP^hcode = INST2^avis.fct(c, t_ident^txt, ARGS^args);
}

#gen{

  INST2^code = APP^code+";";
}

INST-> t_new #trans VAR t_point t_ident t_paro ARGS t_parf t_pointvirgule #gen;
#trans{
  Vector a;
  Vector ts;

  a =  new Vector();
  ARGS^hargs = a;
  ts =  new Vector();
  ARGS^htypes = ts;
}

#gen{
  Resolveur r;

  if (! VAR^entree.affectable(INST^act.getPos())) {
    error(LACTION_var_illegal_access, VAR^entree.getNom());
	}
  else {
    VAR^entree.setEtat(true);
    INST^code = INST^avis.nouveau(VAR^entree, ARGS^args);
    r = INST^act.getResolveur();
    r.contProc(VAR^entree.getType(), t_ident^txt, ARGS^types);
	}
  
}

INST-> t_write t_paro EXPR t_parf t_pointvirgule #gen;
#gen{

  INST^code = INST^avis.ecrire(EXPR^code);
}

INST-> t_error t_paro t_ident #trans EARGS t_parf t_pointvirgule #gen;
#trans{
  Vector a;
  Vector ts;

  a =  new Vector();
  EARGS^hargs = a;
  ts =  new Vector();
  EARGS^htypes = ts;
}

#gen{
  Resolveur r;

  INST^table.addProperty(t_ident^txt, EARGS^args.size());
  INST^code = INST^avis.fatal(t_ident^txt, EARGS^args);
  r = INST^act.getResolveur();
  r.contErr(EARGS^types);
}

INST-> t_attention t_paro t_ident #trans EARGS t_parf t_pointvirgule #gen;
#trans{
  Vector a;
  Vector ts;

  a =  new Vector();
  EARGS^hargs = a;
  ts =  new Vector();
  EARGS^htypes = ts;
}

#gen{
  Resolveur r;

  INST^table.addProperty(t_ident^txt, EARGS^args.size());
  INST^code = INST^avis.signaler(t_ident^txt, EARGS^args);
  r = INST^act.getResolveur();
  r.contErr(EARGS^types);
}

EARGS-> #gen;
#gen{

  EARGS^args = EARGS^hargs;
  EARGS^types = EARGS^htypes;
}

EARGS-> t_virgule EXPR #add EARGS #gen;
#add{

  EARGS^hargs.add(EXPR^code);
  EARGS^htypes.add(EXPR^type);
  EARGS1^htypes = EARGS^htypes;
}

#gen{

  EARGS^args = EARGS1^args;
  EARGS^types = EARGS1^types;
}

INST-> t_if t_paro EXPR t_parf t_aco #inc INSTS t_acf #dec ELSIF #gen;
#inc{

  INST^avis.incIndent();
  INSTS^tds_act =  new TDS_ACTION(INST^tds_act);
}

#dec{

  INST^avis.decIndent();
}

#gen{
  STRING a;
  STRING b;

  a = INSTS^code;
  b = ELSIF^code;
  INST^code = INST^avis.ifExpr(EXPR^code, a, b);
}

ELSIF-> t_elseif t_paro EXPR t_parf t_aco #inc INSTS t_acf #dec ELSIF #gen;
#inc{

  ELSIF^avis.incIndent();
  INSTS^tds_act =  new TDS_ACTION(ELSIF^tds_act);
}

#dec{

  ELSIF^avis.decIndent();
}

#gen{
  STRING a;
  STRING b;

  a = INSTS^code;
  b = ELSIF1^code;
  ELSIF^code = ELSIF^avis.indent()@ELSIF^avis.ifSinonSi(EXPR^code, a, b);
}

ELSIF-> t_else t_aco #inc INSTS t_acf #gen;
#inc{

  ELSIF^avis.incIndent();
  INSTS^tds_act =  new TDS_ACTION(ELSIF^tds_act);
}

#gen{
  STRING a;

  a = INSTS^code;
  ELSIF^avis.decIndent();
  ELSIF^code = ELSIF^avis.indent()@ELSIF^avis.ifSinon(a)@ELSIF^avis.indent()@ELSIF^avis.ifFin();
}

ELSIF-> #gen;
#gen{

  ELSIF^code = ELSIF^avis.indent()@ELSIF^avis.ifFin();
}

VAR-> t_ident #gen;
#gen{
  TDS_ACTION t;
  ENTREE e;
  Resolveur r;

  t = VAR^tds_act;
  e = t.chercher(t_ident^txt);
  if (e==null) {
    error(LACTION_not_a_var, t_ident^txt);
	}
  else {
    VAR^entree = e;
	}
  
}

VAR-> t_ident t_chapeau t_ident #gen;
#gen{
  TDS_ACTION t;
  ENTREE e;
  STRING s;
  SYMBOLE symb;
  Resolveur r;

  t = VAR^tds_act;
  s = t_ident^txt@"^"@t_ident1^txt;
  e = t.chercher(s);
  if (e==null) {
    error(LACTION_not_an_attribute, t_ident1^txt, t_ident^txt);
	}
  else {
    VAR^entree = e;
	}
  
}

INST-> t_match t_paro VAR t_parf #check t_aco CASE CASES t_acf #gen;
#check{

  if (! VAR^entree.getEtat()) {
    error(LACTION_var_non_initialized, VAR^entree.getNom());
	}
  elseif (! VAR^entree.utilisable(INST^act.getPos())) {
    error(LACTION_var_illegal_access, VAR^entree.getNom());
	}
  
  CASE^hentree = VAR^entree;
  CASES^hentree = VAR^entree;
}

#gen{

  INST^code = INST^avis.matchVarAvec(VAR^entree, CASE^type, CASE^code, CASES^code)@INST^avis.indent()@INST^avis.matchSi(VAR^entree, CASE^type, CASE^code, CASES^code);
}

CASE-> t_case #res TYPE #trans t_aco INSTS t_acf #gen;
#res{
  Resolveur r;

  r = CASE^act.getResolveur();
  TYPE^res = r;
}

#trans{

  CASE^avis.incIndent();
  CASE^avis.transtyper(CASE^hentree, TYPE^type);
  INSTS^tds_act =  new TDS_ACTION(CASE^tds_act);
}

#gen{

  CASE^type = TYPE^type;
  CASE^nom = TYPE^type.getNom();
  CASE^code = INSTS^code;
  CASE^avis.decIndent();
  CASE^avis.detranstyper(CASE^hentree);
}

CASES-> CASE CASES #gen;
#gen{

  CASES^code = CASES^avis.indent()@CASES^avis.matchSinonSi(CASES^hentree, CASE^type, CASE^code, CASES1^code);
}

CASES-> t_default #inc t_aco INSTS t_acf #gen;
#inc{

  CASES^avis.incIndent();
  INSTS^tds_act =  new TDS_ACTION(CASES^tds_act);
}

#gen{
  STRING a;

  a = INSTS^code;
  CASES^avis.decIndent();
  CASES^code = CASES^avis.indent()@CASES^avis.matchSinon(a)@CASES^avis.indent()@CASES^avis.matchFin();
}

CASES-> #gen;
#gen{

  CASES^code = CASES^avis.indent()@CASES^avis.matchFin();
}

----------------------------------

EXPR-> REL #code EXPRREL #gen;
#code{

  EXPRREL^hcode = REL^code;
  EXPRREL^htype = REL^type;
}

#gen{

  EXPR^type = EXPRREL^type;
  EXPR^code = EXPRREL^code;
}

EXPRREL-> OPBOOL REL #code EXPRREL #gen;
#code{
  Resolveur r;

  r = EXPRREL^act.getResolveur();
  EXPRREL1^htype = r.contOp(EXPRREL^htype, OPBOOL^nom, REL^type);
  EXPRREL1^hcode = EXPRREL^avis.opBool(EXPRREL^hcode, OPBOOL^nom, REL^code);
}

#gen{

  EXPRREL^type = EXPRREL1^type;
  EXPRREL^code = EXPRREL1^code;
}

OPBOOL-> t_et #gen;
#gen{

  OPBOOL^nom = "and";
}

OPBOOL-> t_ou #gen;
#gen{

  OPBOOL^nom = "or";
}

EXPRREL-> #gen;
#gen{

  EXPRREL^type = EXPRREL^htype;
  EXPRREL^code = EXPRREL^hcode;
}

----------------------------------

REL-> MEXPR #code RELMEXPR #gen;
#code{

  RELMEXPR^hcode = MEXPR^code;
  RELMEXPR^htype = MEXPR^type;
}

#gen{

  REL^type = RELMEXPR^type;
  REL^code = RELMEXPR^code;
}

RELMEXPR-> OPCOMP MEXPR #code RELMEXPR #gen;
#code{
  Resolveur r;

  r = RELMEXPR^act.getResolveur();
  RELMEXPR1^htype = r.contOp(RELMEXPR^htype, OPCOMP^nom, MEXPR^type);
  RELMEXPR1^hcode = RELMEXPR^avis.opComp(RELMEXPR^hcode, OPCOMP^nom, MEXPR^code);
}

#gen{

  RELMEXPR^type = RELMEXPR1^type;
  RELMEXPR^code = RELMEXPR1^code;
}

OPCOMP-> t_inf #gen;
#gen{

  OPCOMP^nom = "<";
}

OPCOMP-> t_inf_egal #gen;
#gen{

  OPCOMP^nom = "<=";
}

OPCOMP-> t_sup #gen;
#gen{

  OPCOMP^nom = ">";
}

OPCOMP-> t_sup_egal #gen;
#gen{

  OPCOMP^nom = ">=";
}

OPCOMP-> t_egal #gen;
#gen{

  OPCOMP^nom = "==";
}

OPCOMP-> t_different #gen;
#gen{

  OPCOMP^nom = "/=";
}

RELMEXPR-> #gen;
#gen{

  RELMEXPR^type = RELMEXPR^htype;
  RELMEXPR^code = RELMEXPR^hcode;
}

----------------------------------

MEXPR-> TERME #code MEXPRTERME #gen;
#code{

  MEXPRTERME^hcode = TERME^code;
  MEXPRTERME^htype = TERME^type;
}

#gen{

  MEXPR^type = MEXPRTERME^type;
  MEXPR^code = MEXPRTERME^code;
}

MEXPRTERME-> OPADD TERME #code MEXPRTERME #gen;
#code{
  Resolveur r;

  r = MEXPRTERME^act.getResolveur();
  MEXPRTERME1^htype = r.contOp(MEXPRTERME^htype, OPADD^nom, TERME^type);
  MEXPRTERME1^hcode = MEXPRTERME^avis.opAdd(MEXPRTERME^hcode, OPADD^nom, TERME^code);
}

#gen{

  MEXPRTERME^type = MEXPRTERME1^type;
  MEXPRTERME^code = MEXPRTERME1^code;
}

OPADD-> t_append #gen;
#gen{

  OPADD^nom = "@";
}

OPADD-> t_plus #gen;
#gen{

  OPADD^nom = "+";
}

OPADD-> t_moins #gen;
#gen{

  OPADD^nom = "-";
}

OPADD-> t_d_plus #gen;
#gen{

  OPADD^nom = "+.";
}

OPADD-> t_d_moins #gen;
#gen{

  OPADD^nom = "-.";
}

MEXPRTERME-> #gen;
#gen{

  MEXPRTERME^type = MEXPRTERME^htype;
  MEXPRTERME^code = MEXPRTERME^hcode;
}

----------------------------------

TERME-> FACTEUR #code TERMEFACTEUR #gen;
#code{

  TERMEFACTEUR^htype = FACTEUR^type;
  TERMEFACTEUR^hcode = FACTEUR^code;
}

#gen{

  TERME^type = TERMEFACTEUR^type;
  TERME^code = TERMEFACTEUR^code;
}

FACTEUR-> t_nil #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("VOID");
  FACTEUR^code = FACTEUR^avis.vide();
}

FACTEUR-> t_true #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("BOOLEAN");
  FACTEUR^code = FACTEUR^avis.vrai();
}

FACTEUR-> t_false #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("BOOLEAN");
  FACTEUR^code = FACTEUR^avis.faux();
}

FACTEUR-> t_entier #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("INTEGER");
  FACTEUR^code = FACTEUR^avis.entier(t_entier^txt);
}

FACTEUR-> t_moins FACTEUR #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("INTEGER");
  FACTEUR^code = FACTEUR^avis.moins(FACTEUR1^code);
}

FACTEUR-> t_flottant #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("DOUBLE");
  FACTEUR^code = FACTEUR^avis.reel(t_flottant^txt);
}

FACTEUR-> t_car #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("CHARACTER");
  FACTEUR^code = FACTEUR^avis.car(t_car^txt);
}

FACTEUR-> t_chaine #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.getType("STRING");
  FACTEUR^code = FACTEUR^avis.chaine(t_chaine^txt);
}

FACTEUR-> VAR #check APP #gen;
#check{

  if (! VAR^entree.getEtat()) {
    error(LACTION_var_non_initialized, VAR^entree.getNom());
	}
  elseif (! VAR^entree.utilisable(FACTEUR^act.getPos())) {
    error(LACTION_var_illegal_access, VAR^entree.getNom());
	}
  else {
    APP^htype = VAR^entree.getType();
    APP^hcode = FACTEUR^avis.var(VAR^entree);
	}
  
}

#gen{

  FACTEUR^type = APP^type;
  FACTEUR^code = APP^code;
}

APP-> #gen;
#gen{

  APP^type = APP^htype;
  APP^code = APP^hcode;
}

APP-> t_point t_ident #trans t_paro ARGS t_parf #hgen APP #gen;
#trans{
  Vector a;
  Vector ts;

  a =  new Vector();
  ARGS^hargs = a;
  ts =  new Vector();
  ARGS^htypes = ts;
}

#hgen{
  Resolveur r;

  r = APP^act.getResolveur();
  APP1^htype = r.contFct(APP^htype, t_ident^txt, ARGS^types);
  APP1^hcode = APP^avis.fct(APP^hcode, t_ident^txt, ARGS^args);
}

#gen{

  APP^type = APP1^type;
  APP^code = APP1^code;
}

FACTEUR-> t_not FACTEUR #gen;
#gen{
  Resolveur r;

  r = FACTEUR^act.getResolveur();
  FACTEUR^type = r.contOpNon(FACTEUR1^type);
  FACTEUR^code = FACTEUR^avis.non(FACTEUR1^code);
}

FACTEUR-> t_paro EXPR t_parf #gen;
#gen{

  FACTEUR^type = EXPR^type;
  FACTEUR^code = "("+EXPR^code+")";
}

FACTEUR-> t_new #trans TYPE t_paro ARGS t_parf #gen;
global
Resolveur r;

#trans{
  Vector a;
  Vector ts;

  r = FACTEUR^act.getResolveur();
  TYPE^res = r;
  a =  new Vector();
  ARGS^hargs = a;
  ts =  new Vector();
  ARGS^htypes = ts;
}

#gen{

  FACTEUR^code = FACTEUR^avis.nouveau(TYPE^type, ARGS^args);
  FACTEUR^type = r.contConst(TYPE^type, ARGS^types);
}

FACTEUR-> t_instanceof t_paro EXPR t_virgule #trans TYPE t_parf #gen;
global
Resolveur r;

#trans{

  r = FACTEUR^act.getResolveur();
  TYPE^res = r;
}

#gen{

  FACTEUR^type = r.getType("BOOLEAN");
  FACTEUR^code = FACTEUR^avis.instanceOf(EXPR^code, TYPE^type);
}

TERMEFACTEUR-> OPMUL FACTEUR #code TERMEFACTEUR #gen;
#code{
  Resolveur r;

  r = TERMEFACTEUR^act.getResolveur();
  TERMEFACTEUR1^htype = r.contOp(TERMEFACTEUR^htype, OPMUL^nom, FACTEUR^type);
  TERMEFACTEUR1^hcode = TERMEFACTEUR^avis.opMul(TERMEFACTEUR^hcode, OPMUL^nom, FACTEUR^code);
}

#gen{

  TERMEFACTEUR^type = TERMEFACTEUR1^type;
  TERMEFACTEUR^code = TERMEFACTEUR1^code;
}

OPMUL-> t_mult #gen;
#gen{

  OPMUL^nom = "*";
}

OPMUL-> t_div #gen;
#gen{

  OPMUL^nom = "/";
}

OPMUL-> t_d_mult #gen;
#gen{

  OPMUL^nom = "*.";
}

OPMUL-> t_d_div #gen;
#gen{

  OPMUL^nom = "/.";
}

TERMEFACTEUR-> #gen;
#gen{

  TERMEFACTEUR^type = TERMEFACTEUR^htype;
  TERMEFACTEUR^code = TERMEFACTEUR^hcode;
}

ARGS-> #gen;
#gen{

  ARGS^args = ARGS^hargs;
  ARGS^types = ARGS^htypes;
}

ARGS-> EXPR #expr ARGSX #gen;
#expr{

  ARGS^hargs.add(EXPR^code);
  ARGS^htypes.add(EXPR^type);
  ARGSX^htypes = ARGS^htypes;
}

#gen{

  ARGS^args = ARGSX^args;
  ARGS^types = ARGSX^types;
}

ARGSX-> #gen;
#gen{

  ARGSX^args = ARGSX^hargs;
  ARGSX^types = ARGSX^htypes;
}

ARGSX-> t_virgule EXPR #expr ARGSX #gen;
#expr{

  ARGSX^hargs.add(EXPR^code);
  ARGSX^htypes.add(EXPR^type);
  ARGSX1^htypes = ARGSX^htypes;
}

#gen{

  ARGSX^args = ARGSX1^args;
  ARGSX^types = ARGSX1^types;
}

